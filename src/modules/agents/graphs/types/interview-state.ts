/**
 * Interview State
 *
 * State schema for the Interview Agent graph.
 * Defines all state fields needed for multi-turn
 * intent extraction conversations.
 */

import { Annotation } from '@langchain/langgraph';

// ============================================================================
// Types
// ============================================================================

/**
 * Phases of the interview graph.
 */
export type InterviewPhase =
  | 'analyze'
  | 'generate_questions'
  | 'waiting_for_response'
  | 'extract_atoms'
  | 'compose_molecule'
  | 'complete';

/**
 * A question generated by the interview agent.
 */
export interface InterviewQuestion {
  /** Unique ID for tracking */
  id: string;
  /** The question text */
  question: string;
  /** Why this question matters */
  rationale: string;
  /** Category of clarification needed */
  category: 'scope' | 'behavior' | 'constraint' | 'acceptance' | 'edge_case';
  /** Whether this question has been answered */
  answered: boolean;
  /** The user's response */
  response?: string;
}

/**
 * An atom candidate extracted from the conversation.
 */
export interface AtomCandidate {
  /** Proposed description */
  description: string;
  /** Atom category */
  category: 'functional' | 'performance' | 'security' | 'ux' | 'operational';
  /** Observable outcomes */
  observableOutcomes: string[];
  /** Confidence in this extraction (0-100) */
  confidence: number;
  /** Which parts of the conversation support this atom */
  sourceEvidence: string[];
}

/**
 * A molecule candidate composed from extracted atoms.
 */
export interface MoleculeCandidate {
  /** Proposed molecule name */
  name: string;
  /** Description */
  description: string;
  /** Suggested lens type */
  lensType: string;
  /** Indices into the atoms array */
  atomIndices: number[];
}

/**
 * A single turn in the interview conversation.
 */
export interface ConversationTurn {
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
}

// ============================================================================
// State Schema
// ============================================================================

/**
 * Interview graph state using LangGraph Annotation.
 */
export const InterviewGraphState = Annotation.Root({
  /** Original user input that started the interview */
  rawIntent: Annotation<string>(),

  /** Current phase of the interview */
  currentPhase: Annotation<InterviewPhase>({
    reducer: (_prev, next) => next,
    default: () => 'analyze',
  }),

  /** Conversation history */
  conversationHistory: Annotation<ConversationTurn[]>({
    reducer: (prev, next) => [...prev, ...next],
    default: () => [],
  }),

  /** Analysis of the initial intent */
  intentAnalysis: Annotation<{
    summary: string;
    ambiguities: string[];
    impliedBehaviors: string[];
    suggestedCategory: string;
  } | null>({
    reducer: (_prev, next) => next,
    default: () => null,
  }),

  /** Questions to ask the user */
  pendingQuestions: Annotation<InterviewQuestion[]>({
    reducer: (_prev, next) => next,
    default: () => [],
  }),

  /** All questions asked across all rounds */
  allQuestions: Annotation<InterviewQuestion[]>({
    reducer: (prev, next) => [...prev, ...next],
    default: () => [],
  }),

  /** Extracted atom candidates */
  atomCandidates: Annotation<AtomCandidate[]>({
    reducer: (_prev, next) => next,
    default: () => [],
  }),

  /** Composed molecule candidates */
  moleculeCandidates: Annotation<MoleculeCandidate[]>({
    reducer: (_prev, next) => next,
    default: () => [],
  }),

  /** Current interview round (1-based) */
  round: Annotation<number>({
    reducer: (_prev, next) => next,
    default: () => 1,
  }),

  /** Maximum rounds before auto-extracting */
  maxRounds: Annotation<number>({
    reducer: (_prev, next) => next,
    default: () => 5,
  }),

  /** Whether the user signaled they're done answering */
  userDone: Annotation<boolean>({
    reducer: (_prev, next) => next,
    default: () => false,
  }),

  /** Errors encountered */
  errors: Annotation<string[]>({
    reducer: (prev, next) => [...prev, ...next],
    default: () => [],
  }),

  /** Final output message for the user */
  output: Annotation<string>({
    reducer: (_prev, next) => next,
    default: () => '',
  }),

  /** LLM call count for cost tracking */
  llmCallCount: Annotation<number>({
    reducer: (_prev, next) => next,
    default: () => 0,
  }),
});

/**
 * Type alias for the interview graph state
 */
export type InterviewGraphStateType = typeof InterviewGraphState.State;
