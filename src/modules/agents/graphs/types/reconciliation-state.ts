/**
 * Reconciliation State
 *
 * State schema for the Reconciliation Agent graph.
 * Defines all state fields needed for repo-Pact reconciliation
 * in both full-scan and delta modes.
 *
 * @see docs/implementation-checklist-phase5.md
 * @see docs/architecture/reconcilation-agent-architecture-proposal.md
 */

import { Annotation } from '@langchain/langgraph';
import type { CoverageData } from '../../coverage/coverage-parser';

// ============================================================================
// Enums
// ============================================================================

/**
 * Reconciliation mode determines how orphan tests are discovered.
 */
export type ReconciliationMode = 'full-scan' | 'delta';

/**
 * Phases of the reconciliation graph.
 */
export type ReconciliationPhase =
  | 'structure'
  | 'discover'
  | 'context'
  | 'infer'
  | 'synthesize'
  | 'verify'
  | 'persist';

/**
 * Decision states during reconciliation.
 */
export type ReconciliationDecision =
  | 'need_more_context'
  | 'ready_to_infer'
  | 'quality_fail'
  | 'approved'
  | 'rejected';

// ============================================================================
// Input Types
// ============================================================================

/**
 * Options for reconciliation runs.
 *
 * Phase 6 additions:
 * - forceInterruptOnQualityFail: Control interrupt behavior
 * - includePaths/excludePaths: Filter tests by folder patterns
 * - includeFilePatterns/excludeFilePatterns: Filter tests by file patterns
 */
/**
 * Exception lanes control drift convergence deadlines
 */
export type ExceptionLane = 'normal' | 'hotfix-exception' | 'spike-exception';

/**
 * Attestation type determines whether drift debt is created
 * - local: Advisory only, no drift records created (default for dev)
 * - ci-attested: Canonical, creates/updates drift records (CI pipeline)
 */
export type AttestationType = 'local' | 'ci-attested';

export interface ReconciliationOptions {
  /** Manifest ID to load pre-computed deterministic analysis from */
  manifestId?: string;
  /** Project ID for policy lookups and atom creation (Phase 18) */
  projectId?: string;
  /** Whether to analyze documentation for context enrichment */
  analyzeDocs?: boolean;
  /** Maximum number of tests to process (for large repos) */
  maxTests?: number;
  /** Whether to auto-create atoms (vs storing as recommendations) */
  autoCreateAtoms?: boolean;
  /** Minimum quality threshold for atom approval (default: 80) */
  qualityThreshold?: number;
  /** Whether to require human review before persisting */
  requireReview?: boolean;
  /**
   * Force interrupt when quality failures exceed passes (default: false).
   * When false, only interrupts if requireReview is explicitly true.
   * When true, interrupts if failCount > passCount (legacy behavior).
   */
  forceInterruptOnQualityFail?: boolean;
  /**
   * Folder paths to include (e.g., `["src/modules/atoms"]`).
   * Only tests under these paths will be analyzed.
   */
  includePaths?: string[];
  /**
   * Folder paths to exclude (e.g., `["test/e2e"]`).
   * Tests under these paths will be skipped.
   */
  excludePaths?: string[];
  /**
   * File name patterns to include (e.g., ["*.service.spec.ts"]).
   */
  includeFilePatterns?: string[];
  /**
   * File name patterns to exclude (e.g., ["*.e2e-spec.ts"]).
   */
  excludeFilePatterns?: string[];

  // Phase 16: Drift management options

  /**
   * Exception lane for drift convergence policy (default: 'normal')
   * - normal: 14-day convergence window
   * - hotfix-exception: 3-day expedited window
   * - spike-exception: 7-day research window
   */
  exceptionLane?: ExceptionLane;

  /**
   * Attestation type (default: 'local')
   * - local: Advisory only, no drift records created
   * - ci-attested: Canonical, creates/updates drift debt
   */
  attestationType?: AttestationType;

  /**
   * Justification for exception lane (required for hotfix/spike)
   */
  exceptionJustification?: string;
}

/**
 * Delta baseline specification for incremental reconciliation.
 */
export interface DeltaBaseline {
  /** Previous reconciliation run ID */
  runId?: string;
  /** Git commit hash to compare against */
  commitHash?: string;
}

/**
 * Input to the reconciliation graph.
 */
export interface ReconciliationInput {
  /** Root directory of the repository to analyze */
  rootDirectory: string;
  /** Whether to run full-scan or delta mode */
  reconciliationMode: ReconciliationMode;
  /** Baseline for delta mode (optional) */
  deltaBaseline?: DeltaBaseline;
  /** Configuration options */
  options: ReconciliationOptions;
  /** Run ID generated by service (ensures consistency across nodes) */
  runId?: string;
}

// ============================================================================
// Repository Structure Types
// ============================================================================

/**
 * Dependency edge between files.
 */
export interface DependencyEdge {
  /** Source file path */
  from: string;
  /** Target file path (imported by source) */
  to: string;
}

/**
 * Repository structure information.
 */
export interface RepoStructure {
  /** All source and test files in the repository */
  files: string[];
  /** Test files specifically (subset of files) */
  testFiles: string[];
  /** Non-test source files */
  sourceFiles?: string[];
  /** UI component files (.tsx/.jsx/.vue/.svelte with component patterns) */
  uiFiles?: string[];
  /** Documentation files (README, docs/, CHANGELOG, etc.) */
  docFiles?: string[];
  /** Configuration files (package.json, tsconfig, etc.) */
  configFiles?: string[];
  /** File dependency edges (optional, for Phase 3) */
  dependencyEdges?: DependencyEdge[];
  /** Topological order for processing (optional, for Phase 3) */
  topologicalOrder?: string[];
  /** Detected frameworks (e.g., ['react', 'nestjs', 'express']) */
  detectedFrameworks?: string[];
  /** Package info extracted from package.json */
  packageInfo?: {
    name?: string;
    description?: string;
    scripts?: Record<string, string>;
  };
}

// ============================================================================
// Evidence Types (Phase 21C)
// ============================================================================

/**
 * Types of evidence that can be discovered in a repository.
 */
export type EvidenceType =
  | 'test'            // Orphan test (existing pipeline)
  | 'source_export'   // Exported function, class, or handler
  | 'ui_component'    // React/Vue/Svelte component
  | 'api_endpoint'    // Route/controller definition
  | 'documentation'   // README, docs, comments
  | 'code_comment'    // JSDoc, task annotations, business logic comments
  | 'coverage_gap';   // Untested code identified via coverage data

/**
 * Default confidence weights by evidence type.
 * Tests are highest (most explicit about behavior), coverage gaps lowest.
 */
export const EVIDENCE_CONFIDENCE_WEIGHTS: Record<EvidenceType, number> = {
  test: 0.9,
  api_endpoint: 0.8,
  ui_component: 0.7,
  source_export: 0.6,
  code_comment: 0.55,
  documentation: 0.5,
  coverage_gap: 0.4,
};

/**
 * A piece of evidence discovered in the repository.
 */
export interface EvidenceItem {
  /** Evidence type discriminator */
  type: EvidenceType;
  /** File where the evidence was found */
  filePath: string;
  /** Name of the evidence (test name, export name, component name, section title) */
  name: string;
  /** Source code snippet */
  code?: string;
  /** Line number in the source file */
  lineNumber?: number;
  /** Files related to this evidence */
  relatedFiles?: string[];
  /** Base confidence from evidence type weights */
  baseConfidence: number;
  /** Type-specific metadata */
  metadata?: EvidenceMetadata;
}

/**
 * Type-specific metadata carried on EvidenceItem.
 */
export interface EvidenceMetadata {
  // test
  testCode?: string;
  relatedSourceFiles?: string[];
  testSourceCode?: string;
  // source_export
  exportType?: 'function' | 'class' | 'const' | 'interface';
  isDefault?: boolean;
  jsdoc?: string;
  // ui_component
  framework?: string;
  hasForm?: boolean;
  hasNavigation?: boolean;
  // api_endpoint
  method?: string;
  path?: string;
  // documentation
  section?: string;
  // code_comment
  commentType?: 'jsdoc' | 'task_annotation' | 'business_logic' | 'atom_reference';
  associatedExport?: string;
  tags?: string[];
  // coverage_gap
  uncoveredLines?: number;
  totalLines?: number;
  coveragePercent?: number;
}

/**
 * Tracks where an inferred atom's evidence came from.
 */
export interface EvidenceSource {
  type: EvidenceType;
  filePath: string;
  name: string;
  confidence: number;
}

/**
 * Context analysis for a single evidence item (replaces TestAnalysis for non-test types).
 */
export interface EvidenceAnalysis {
  /** Evidence identifier (filePath:name) */
  evidenceId: string;
  /** Evidence type */
  type: EvidenceType;
  /** Summary of what the evidence represents */
  summary: string;
  /** Domain concepts extracted */
  domainConcepts: string[];
  /** Related source code snippets */
  relatedCode?: string[];
  /** Related documentation snippets */
  relatedDocs?: string[];
  /** Raw context (cleared after inference) */
  rawContext?: string;
  /** Quality score (tests only, from test quality node) */
  qualityScore?: number;
}

// ============================================================================
// Test Quality Types
// ============================================================================

/**
 * Quality score for an individual test, produced by the test_quality node.
 */
export interface TestQualityScore {
  /** Overall quality score (0-100) */
  overallScore: number;
  /** Whether the test passed quality threshold */
  passed: boolean;
  /** Scores per dimension (0-1 normalized) */
  dimensions: {
    intentFidelity: number;
    noVacuousTests: number;
    noBrittleTests: number;
    determinism: number;
    failureSignalQuality: number;
    integrationAuthenticity: number;
    boundaryAndNegativeCoverage: number;
  };
  /** Human-readable issue descriptions */
  issues: string[];
}

// ============================================================================
// Test Analysis Types
// ============================================================================

/**
 * Information about an orphan test (test without @atom annotation).
 */
export interface OrphanTestInfo {
  /** Path to the test file */
  filePath: string;
  /** Name of the test (from describe/it blocks) */
  testName: string;
  /** Line number where the test starts */
  lineNumber: number;
  /** The actual test code */
  testCode: string;
  /** Source files that the test might be testing */
  relatedSourceFiles?: string[];
  /** Whether this test was part of a delta change */
  isDeltaChange?: boolean;
  /**
   * Full source code of the test file (Phase 14: Ingestion Boundary).
   * Stored during discovery so quality analysis can run from the database
   * without re-reading the filesystem.
   */
  testSourceCode?: string;
}

/**
 * Analysis result from ContextBuilderService for a single test.
 */
export interface TestAnalysis {
  /** Test identifier (filePath:testName) */
  testId: string;
  /** Summary of what the test appears to validate */
  summary: string;
  /** Domain concepts extracted from the test */
  domainConcepts: string[];
  /** Related source code snippets */
  relatedCode?: string[];
  /** Related documentation snippets */
  relatedDocs?: string[];
  /** Raw context (cleared after inference per INV-R005) */
  rawContext?: string;
}

// ============================================================================
// Inference Types
// ============================================================================

/**
 * Source test reference for an inferred atom.
 */
export interface SourceTestReference {
  /** Path to the test file */
  filePath: string;
  /** Name of the test */
  testName: string;
  /** Line number where the test starts */
  lineNumber: number;
}

/**
 * An atom inferred from evidence (test, source, UI, API, docs, or coverage gap).
 * This is a recommendation, not yet persisted.
 */
export interface InferredAtom {
  /** Temporary ID for cross-references within the run */
  tempId: string;
  /** Description of the behavioral intent */
  description: string;
  /** Category (e.g., functional, security, performance) */
  category: string;
  /** Test that this atom was inferred from (backward compat, populated when primary evidence is test) */
  sourceTest: SourceTestReference;
  /** Observable outcomes that can be verified */
  observableOutcomes: string[];
  /** Confidence score (0-100) */
  confidence: number;
  /** Reasons for any ambiguity in the inference */
  ambiguityReasons?: string[];
  /** LLM reasoning for the inference */
  reasoning: string;
  /** Related documentation that informed the inference */
  relatedDocs?: string[];
  /** Quality score after validation (optional) */
  qualityScore?: number;
  /** All evidence sources supporting this atom (Phase 21C) */
  evidenceSources?: EvidenceSource[];
  /** Primary evidence type (Phase 21C) */
  primaryEvidenceType?: EvidenceType;
}

/**
 * A molecule inferred from clustering atoms.
 * This is a recommendation, not yet persisted.
 */
export interface InferredMolecule {
  /** Temporary ID for cross-references within the run */
  tempId: string;
  /** Name of the molecule (feature/capability) */
  name: string;
  /** Description of what the molecule represents */
  description: string;
  /** Gherkin scenario describing the molecule's behavior (Given/When/Then) */
  gherkinScenario?: string;
  /** Temporary IDs of atoms in this molecule */
  atomTempIds: string[];
  /** Confidence score (0-100) */
  confidence: number;
  /** LLM reasoning for the grouping */
  reasoning: string;
}

// ============================================================================
// Documentation Index Types (Optional)
// ============================================================================

/**
 * A chunk of documentation for context enrichment.
 */
export interface DocChunk {
  /** Source file path */
  filePath: string;
  /** The content of the chunk */
  content: string;
  /** Keywords or concepts in the chunk */
  keywords: string[];
}

// ============================================================================
// Human Review Types (Phase 4)
// ============================================================================

/**
 * Human review decision for a single recommendation.
 */
export interface ReviewDecision {
  /** ID of the recommendation (atom or molecule tempId) */
  recommendationId: string;
  /** Human decision */
  decision: 'approve' | 'reject';
  /** Optional reason for rejection */
  reason?: string;
}

/**
 * Human input provided during review interrupt.
 */
export interface HumanReviewInput {
  /** List of review decisions for atoms */
  atomDecisions: ReviewDecision[];
  /** List of review decisions for molecules */
  moleculeDecisions: ReviewDecision[];
  /** Optional overall comment */
  comment?: string;
}

// ============================================================================
// Delta Mode Types
// ============================================================================

/**
 * Summary of delta changes for reporting.
 */
export interface DeltaSummary {
  /** Number of orphan tests in the delta */
  deltaOrphanCount: number;
  /** Number of tests with @atom that changed */
  changedLinkedTestCount: number;
  /** Files that were modified since baseline */
  modifiedFiles: string[];
  /** Baseline information used */
  baseline: DeltaBaseline;
}

/**
 * Information about a test that has an @atom annotation and was changed.
 *
 * Per INV-R001: These tests MUST NOT flow to infer_atoms node.
 * They can only generate warnings or supersession recommendations.
 */
export interface ChangedAtomLinkedTest {
  /** Path to the test file */
  filePath: string;
  /** Name of the test */
  testName: string;
  /** Line number where the test starts */
  lineNumber: number;
  /** The atom ID from the @atom annotation */
  linkedAtomId: string;
  /** Type of change: added, modified, or deleted */
  changeType: 'added' | 'modified' | 'deleted';
}

// ============================================================================
// State Lifecycle Management (INV-R005)
// ============================================================================

/**
 * Tracks which state fields are valid in which phases.
 * Used to enforce cleanup at phase transitions.
 */
export const PHASE_VALID_FIELDS: Record<ReconciliationPhase, string[]> = {
  structure: ['input', 'rootDirectory'],
  discover: ['input', 'rootDirectory', 'repoStructure'],
  context: ['input', 'rootDirectory', 'repoStructure', 'orphanTests', 'changedAtomLinkedTests'],
  infer: ['input', 'rootDirectory', 'repoStructure', 'orphanTests', 'contextPerTest'],
  synthesize: ['input', 'rootDirectory', 'orphanTests', 'inferredAtoms'],
  verify: ['input', 'rootDirectory', 'inferredAtoms', 'inferredMolecules'],
  persist: ['input', 'rootDirectory', 'inferredAtoms', 'inferredMolecules', 'decisions'],
};

/**
 * Fields that should be cleared after their phase is complete (transient).
 */
export const TRANSIENT_FIELDS = [
  'rawContext', // Cleared from contextPerTest after infer phase
];

/**
 * Helper function to clean up state between phase transitions.
 * Implements INV-R005: State Lifecycle Management.
 *
 * @param state - Current graph state
 * @param fromPhase - Phase we're leaving
 * @param toPhase - Phase we're entering
 * @returns Partial state update with cleaned fields
 */
export function cleanupPhaseState(
  state: ReconciliationGraphStateType,
  fromPhase: ReconciliationPhase,
  toPhase: ReconciliationPhase,
): Partial<ReconciliationGraphStateType> {
  const updates: Partial<ReconciliationGraphStateType> = {};

  // After infer phase: clear raw context blobs (keep only normalized summaries)
  if (fromPhase === 'infer' && state.contextPerTest) {
    const cleanedContext = new Map<string, TestAnalysis>();
    for (const [key, analysis] of state.contextPerTest) {
      // Remove rawContext to save memory
      const { rawContext: _, ...cleanedAnalysis } = analysis;
      cleanedContext.set(key, cleanedAnalysis);
    }
    updates.contextPerTest = cleanedContext;
  }

  return updates;
}

// ============================================================================
// Forward Declaration for Result Type (defined in reconciliation-result.ts)
// ============================================================================

// ReconciliationResult is defined in a separate file to avoid circular imports
// It will be imported where needed

// ============================================================================
// Graph State Definition
// ============================================================================

/**
 * Full state for the Reconciliation Agent graph.
 * Uses LangGraph's Annotation system for type-safe state management.
 */
export const ReconciliationGraphState = Annotation.Root({
  // -------------------------------------------------------------------------
  // Input Configuration
  // -------------------------------------------------------------------------

  /** Root directory of the repository */
  rootDirectory: Annotation<string>({
    reducer: (_, update) => update,
    default: () => '',
  }),

  /** Full input configuration */
  input: Annotation<ReconciliationInput | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Run ID for tracking and cancellation (passed from service layer) */
  runId: Annotation<string>({
    reducer: (_, update) => update,
    default: () => '',
  }),

  // -------------------------------------------------------------------------
  // Repository Structure (Phase: structure)
  // -------------------------------------------------------------------------

  /** Structure of the repository */
  repoStructure: Annotation<RepoStructure | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  // -------------------------------------------------------------------------
  // Orphan Tests (Phase: discover)
  // -------------------------------------------------------------------------

  /** Tests without @atom annotation (to be processed) */
  orphanTests: Annotation<OrphanTestInfo[]>({
    reducer: (_, update) => update,
    default: () => [],
  }),

  /**
   * Tests with @atom annotation that changed (delta mode only).
   * INV-R001: These MUST NOT flow to infer_atoms - only generate warnings.
   */
  changedAtomLinkedTests: Annotation<ChangedAtomLinkedTest[]>({
    reducer: (_, update) => update,
    default: () => [],
  }),

  /** Summary of delta changes (delta mode only) */
  deltaSummary: Annotation<DeltaSummary | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  // -------------------------------------------------------------------------
  // Coverage Data (Phase: structure — Phase 21D)
  // -------------------------------------------------------------------------

  /** Parsed coverage data from existing artifacts (null if none found) */
  coverageData: Annotation<CoverageData | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  // -------------------------------------------------------------------------
  // Evidence Items (Phase: discover — Phase 21C)
  // -------------------------------------------------------------------------

  /** All evidence items discovered from all sources */
  evidenceItems: Annotation<EvidenceItem[]>({
    reducer: (_, update) => update,
    default: () => [],
  }),

  // -------------------------------------------------------------------------
  // Test Quality (Phase: test_quality)
  // -------------------------------------------------------------------------

  /** Per-test quality scores (key: filePath:testName) */
  testQualityScores: Annotation<Map<string, TestQualityScore>>({
    reducer: (_, update) => update,
    default: () => new Map(),
  }),

  // -------------------------------------------------------------------------
  // Evidence Analysis (Phase: context — Phase 21C)
  // -------------------------------------------------------------------------

  /** Per-evidence analysis (key: filePath:name) */
  evidenceAnalysis: Annotation<Map<string, EvidenceAnalysis>>({
    reducer: (_, update) => update,
    default: () => new Map(),
  }),

  // -------------------------------------------------------------------------
  // Context Enrichment (Phase: context)
  // -------------------------------------------------------------------------

  /** Documentation index for context enrichment */
  documentationIndex: Annotation<DocChunk[] | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Test analysis per test (key: filePath:testName) */
  contextPerTest: Annotation<Map<string, TestAnalysis>>({
    reducer: (_, update) => update,
    default: () => new Map(),
  }),

  // -------------------------------------------------------------------------
  // Inference Results (Phase: infer)
  // -------------------------------------------------------------------------

  /** Atoms inferred from tests */
  inferredAtoms: Annotation<InferredAtom[]>({
    reducer: (_, update) => update,
    default: () => [],
  }),

  // -------------------------------------------------------------------------
  // Molecule Synthesis (Phase: synthesize)
  // -------------------------------------------------------------------------

  /** Molecules synthesized from atoms */
  inferredMolecules: Annotation<InferredMolecule[]>({
    reducer: (_, update) => update,
    default: () => [],
  }),

  // -------------------------------------------------------------------------
  // Verification and Decisions (Phase: verify)
  // -------------------------------------------------------------------------

  /** Current phase of the reconciliation */
  currentPhase: Annotation<ReconciliationPhase>({
    reducer: (_, update) => update,
    default: () => 'structure' as ReconciliationPhase,
  }),

  /** Iteration count (for bounded loops) */
  iteration: Annotation<number>({
    reducer: (_, update) => update,
    default: () => 0,
  }),

  /** Maximum iterations allowed */
  maxIterations: Annotation<number>({
    reducer: (_, update) => update,
    default: () => 10,
  }),

  /** Accumulated errors during processing */
  errors: Annotation<string[]>({
    reducer: (current, update) => [...current, ...update],
    default: () => [],
  }),

  /** Decisions made during verification */
  decisions: Annotation<ReconciliationDecision[]>({
    reducer: (_, update) => update,
    default: () => [],
  }),

  /** Whether human review is pending (for interrupt support) */
  pendingHumanReview: Annotation<boolean>({
    reducer: (_, update) => update,
    default: () => false,
  }),

  /** Human review input after interrupt (populated on resume) */
  humanReviewInput: Annotation<HumanReviewInput | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Whether the run was resumed after an interrupt */
  wasResumed: Annotation<boolean>({
    reducer: (_, update) => update,
    default: () => false,
  }),

  // -------------------------------------------------------------------------
  // Output (Phase: persist)
  // -------------------------------------------------------------------------

  /** Final reconciliation result */
  output: Annotation<unknown | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  // -------------------------------------------------------------------------
  // Interim Persistence (Phase 6)
  // -------------------------------------------------------------------------

  /** Interim run ID (short form like REC-abc123) created before verification */
  interimRunId: Annotation<string | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Interim run UUID created before verification */
  interimRunUuid: Annotation<string | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  // -------------------------------------------------------------------------
  // Metadata
  // -------------------------------------------------------------------------

  /** Start time for duration tracking */
  startTime: Annotation<Date | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Count of LLM calls made */
  llmCallCount: Annotation<number>({
    reducer: (current, update) => current + update,
    default: () => 0,
  }),

  // -------------------------------------------------------------------------
  // Fixture Mode (Golden Test Evaluation)
  // -------------------------------------------------------------------------

  /** Whether running in fixture mode (golden tests) */
  fixtureMode: Annotation<boolean>({
    reducer: (_, update) => update,
    default: () => false,
  }),

  /** File contents for fixture mode (key: relative path, value: content) */
  fixtureFiles: Annotation<Record<string, string> | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Test file paths for fixture mode */
  fixtureTestFiles: Annotation<string[] | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Source file paths for fixture mode */
  fixtureSourceFiles: Annotation<string[] | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Existing annotations for fixture mode (key: "filePath:testName", value: atomId) */
  fixtureAnnotations: Annotation<Record<string, string> | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Existing atoms for fixture mode */
  fixtureAtoms: Annotation<Array<{ id: string; description: string }> | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),
});

export type ReconciliationGraphStateType = typeof ReconciliationGraphState.State;
