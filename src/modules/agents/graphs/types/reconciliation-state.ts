/**
 * Reconciliation State
 *
 * State schema for the Reconciliation Agent graph.
 * Defines all state fields needed for repo-Pact reconciliation
 * in both full-scan and delta modes.
 *
 * @see docs/implementation-checklist-phase5.md
 * @see docs/architecture/reconcilation-agent-architecture-proposal.md
 */

import { Annotation } from '@langchain/langgraph';

// ============================================================================
// Enums
// ============================================================================

/**
 * Reconciliation mode determines how orphan tests are discovered.
 */
export type ReconciliationMode = 'full-scan' | 'delta';

/**
 * Phases of the reconciliation graph.
 */
export type ReconciliationPhase =
  | 'structure'
  | 'discover'
  | 'context'
  | 'infer'
  | 'synthesize'
  | 'verify'
  | 'persist';

/**
 * Decision states during reconciliation.
 */
export type ReconciliationDecision =
  | 'need_more_context'
  | 'ready_to_infer'
  | 'quality_fail'
  | 'approved'
  | 'rejected';

// ============================================================================
// Input Types
// ============================================================================

/**
 * Options for reconciliation runs.
 *
 * Phase 6 additions:
 * - forceInterruptOnQualityFail: Control interrupt behavior
 * - includePaths/excludePaths: Filter tests by folder patterns
 * - includeFilePatterns/excludeFilePatterns: Filter tests by file patterns
 */
/**
 * Exception lanes control drift convergence deadlines
 */
export type ExceptionLane = 'normal' | 'hotfix-exception' | 'spike-exception';

/**
 * Attestation type determines whether drift debt is created
 * - local: Advisory only, no drift records created (default for dev)
 * - ci-attested: Canonical, creates/updates drift records (CI pipeline)
 */
export type AttestationType = 'local' | 'ci-attested';

export interface ReconciliationOptions {
  /** Project ID for policy lookups and atom creation (Phase 18) */
  projectId?: string;
  /** Whether to analyze documentation for context enrichment */
  analyzeDocs?: boolean;
  /** Maximum number of tests to process (for large repos) */
  maxTests?: number;
  /** Whether to auto-create atoms (vs storing as recommendations) */
  autoCreateAtoms?: boolean;
  /** Minimum quality threshold for atom approval (default: 80) */
  qualityThreshold?: number;
  /** Whether to require human review before persisting */
  requireReview?: boolean;
  /**
   * Force interrupt when quality failures exceed passes (default: false).
   * When false, only interrupts if requireReview is explicitly true.
   * When true, interrupts if failCount > passCount (legacy behavior).
   */
  forceInterruptOnQualityFail?: boolean;
  /**
   * Folder paths to include (e.g., `["src/modules/atoms"]`).
   * Only tests under these paths will be analyzed.
   */
  includePaths?: string[];
  /**
   * Folder paths to exclude (e.g., `["test/e2e"]`).
   * Tests under these paths will be skipped.
   */
  excludePaths?: string[];
  /**
   * File name patterns to include (e.g., ["*.service.spec.ts"]).
   */
  includeFilePatterns?: string[];
  /**
   * File name patterns to exclude (e.g., ["*.e2e-spec.ts"]).
   */
  excludeFilePatterns?: string[];

  // Phase 16: Drift management options

  /**
   * Exception lane for drift convergence policy (default: 'normal')
   * - normal: 14-day convergence window
   * - hotfix-exception: 3-day expedited window
   * - spike-exception: 7-day research window
   */
  exceptionLane?: ExceptionLane;

  /**
   * Attestation type (default: 'local')
   * - local: Advisory only, no drift records created
   * - ci-attested: Canonical, creates/updates drift debt
   */
  attestationType?: AttestationType;

  /**
   * Justification for exception lane (required for hotfix/spike)
   */
  exceptionJustification?: string;
}

/**
 * Delta baseline specification for incremental reconciliation.
 */
export interface DeltaBaseline {
  /** Previous reconciliation run ID */
  runId?: string;
  /** Git commit hash to compare against */
  commitHash?: string;
}

/**
 * Input to the reconciliation graph.
 */
export interface ReconciliationInput {
  /** Root directory of the repository to analyze */
  rootDirectory: string;
  /** Whether to run full-scan or delta mode */
  reconciliationMode: ReconciliationMode;
  /** Baseline for delta mode (optional) */
  deltaBaseline?: DeltaBaseline;
  /** Configuration options */
  options: ReconciliationOptions;
  /** Run ID generated by service (ensures consistency across nodes) */
  runId?: string;
}

// ============================================================================
// Repository Structure Types
// ============================================================================

/**
 * Dependency edge between files.
 */
export interface DependencyEdge {
  /** Source file path */
  from: string;
  /** Target file path (imported by source) */
  to: string;
}

/**
 * Repository structure information.
 */
export interface RepoStructure {
  /** All source and test files in the repository */
  files: string[];
  /** Test files specifically (subset of files) */
  testFiles: string[];
  /** File dependency edges (optional, for Phase 3) */
  dependencyEdges?: DependencyEdge[];
  /** Topological order for processing (optional, for Phase 3) */
  topologicalOrder?: string[];
}

// ============================================================================
// Test Analysis Types
// ============================================================================

/**
 * Information about an orphan test (test without @atom annotation).
 */
export interface OrphanTestInfo {
  /** Path to the test file */
  filePath: string;
  /** Name of the test (from describe/it blocks) */
  testName: string;
  /** Line number where the test starts */
  lineNumber: number;
  /** The actual test code */
  testCode: string;
  /** Source files that the test might be testing */
  relatedSourceFiles?: string[];
  /** Whether this test was part of a delta change */
  isDeltaChange?: boolean;
  /**
   * Full source code of the test file (Phase 14: Ingestion Boundary).
   * Stored during discovery so quality analysis can run from the database
   * without re-reading the filesystem.
   */
  testSourceCode?: string;
}

/**
 * Analysis result from ContextBuilderService for a single test.
 */
export interface TestAnalysis {
  /** Test identifier (filePath:testName) */
  testId: string;
  /** Summary of what the test appears to validate */
  summary: string;
  /** Domain concepts extracted from the test */
  domainConcepts: string[];
  /** Related source code snippets */
  relatedCode?: string[];
  /** Related documentation snippets */
  relatedDocs?: string[];
  /** Raw context (cleared after inference per INV-R005) */
  rawContext?: string;
}

// ============================================================================
// Inference Types
// ============================================================================

/**
 * Source test reference for an inferred atom.
 */
export interface SourceTestReference {
  /** Path to the test file */
  filePath: string;
  /** Name of the test */
  testName: string;
  /** Line number where the test starts */
  lineNumber: number;
}

/**
 * An atom inferred from a test.
 * This is a recommendation, not yet persisted.
 */
export interface InferredAtom {
  /** Temporary ID for cross-references within the run */
  tempId: string;
  /** Description of the behavioral intent */
  description: string;
  /** Category (e.g., functional, security, performance) */
  category: string;
  /** Test that this atom was inferred from */
  sourceTest: SourceTestReference;
  /** Observable outcomes that can be verified */
  observableOutcomes: string[];
  /** Confidence score (0-100) */
  confidence: number;
  /** Reasons for any ambiguity in the inference */
  ambiguityReasons?: string[];
  /** LLM reasoning for the inference */
  reasoning: string;
  /** Related documentation that informed the inference */
  relatedDocs?: string[];
  /** Quality score after validation (optional) */
  qualityScore?: number;
}

/**
 * A molecule inferred from clustering atoms.
 * This is a recommendation, not yet persisted.
 */
export interface InferredMolecule {
  /** Temporary ID for cross-references within the run */
  tempId: string;
  /** Name of the molecule (feature/capability) */
  name: string;
  /** Description of what the molecule represents */
  description: string;
  /** Temporary IDs of atoms in this molecule */
  atomTempIds: string[];
  /** Confidence score (0-100) */
  confidence: number;
  /** LLM reasoning for the grouping */
  reasoning: string;
}

// ============================================================================
// Documentation Index Types (Optional)
// ============================================================================

/**
 * A chunk of documentation for context enrichment.
 */
export interface DocChunk {
  /** Source file path */
  filePath: string;
  /** The content of the chunk */
  content: string;
  /** Keywords or concepts in the chunk */
  keywords: string[];
}

// ============================================================================
// Human Review Types (Phase 4)
// ============================================================================

/**
 * Human review decision for a single recommendation.
 */
export interface ReviewDecision {
  /** ID of the recommendation (atom or molecule tempId) */
  recommendationId: string;
  /** Human decision */
  decision: 'approve' | 'reject';
  /** Optional reason for rejection */
  reason?: string;
}

/**
 * Human input provided during review interrupt.
 */
export interface HumanReviewInput {
  /** List of review decisions for atoms */
  atomDecisions: ReviewDecision[];
  /** List of review decisions for molecules */
  moleculeDecisions: ReviewDecision[];
  /** Optional overall comment */
  comment?: string;
}

// ============================================================================
// Delta Mode Types
// ============================================================================

/**
 * Summary of delta changes for reporting.
 */
export interface DeltaSummary {
  /** Number of orphan tests in the delta */
  deltaOrphanCount: number;
  /** Number of tests with @atom that changed */
  changedLinkedTestCount: number;
  /** Files that were modified since baseline */
  modifiedFiles: string[];
  /** Baseline information used */
  baseline: DeltaBaseline;
}

/**
 * Information about a test that has an @atom annotation and was changed.
 *
 * Per INV-R001: These tests MUST NOT flow to infer_atoms node.
 * They can only generate warnings or supersession recommendations.
 */
export interface ChangedAtomLinkedTest {
  /** Path to the test file */
  filePath: string;
  /** Name of the test */
  testName: string;
  /** Line number where the test starts */
  lineNumber: number;
  /** The atom ID from the @atom annotation */
  linkedAtomId: string;
  /** Type of change: added, modified, or deleted */
  changeType: 'added' | 'modified' | 'deleted';
}

// ============================================================================
// State Lifecycle Management (INV-R005)
// ============================================================================

/**
 * Tracks which state fields are valid in which phases.
 * Used to enforce cleanup at phase transitions.
 */
export const PHASE_VALID_FIELDS: Record<ReconciliationPhase, string[]> = {
  structure: ['input', 'rootDirectory'],
  discover: ['input', 'rootDirectory', 'repoStructure'],
  context: ['input', 'rootDirectory', 'repoStructure', 'orphanTests', 'changedAtomLinkedTests'],
  infer: ['input', 'rootDirectory', 'repoStructure', 'orphanTests', 'contextPerTest'],
  synthesize: ['input', 'rootDirectory', 'orphanTests', 'inferredAtoms'],
  verify: ['input', 'rootDirectory', 'inferredAtoms', 'inferredMolecules'],
  persist: ['input', 'rootDirectory', 'inferredAtoms', 'inferredMolecules', 'decisions'],
};

/**
 * Fields that should be cleared after their phase is complete (transient).
 */
export const TRANSIENT_FIELDS = [
  'rawContext', // Cleared from contextPerTest after infer phase
];

/**
 * Helper function to clean up state between phase transitions.
 * Implements INV-R005: State Lifecycle Management.
 *
 * @param state - Current graph state
 * @param fromPhase - Phase we're leaving
 * @param toPhase - Phase we're entering
 * @returns Partial state update with cleaned fields
 */
export function cleanupPhaseState(
  state: ReconciliationGraphStateType,
  fromPhase: ReconciliationPhase,
  toPhase: ReconciliationPhase,
): Partial<ReconciliationGraphStateType> {
  const updates: Partial<ReconciliationGraphStateType> = {};

  // After infer phase: clear raw context blobs (keep only normalized summaries)
  if (fromPhase === 'infer' && state.contextPerTest) {
    const cleanedContext = new Map<string, TestAnalysis>();
    for (const [key, analysis] of state.contextPerTest) {
      // Remove rawContext to save memory
      const { rawContext: _, ...cleanedAnalysis } = analysis;
      cleanedContext.set(key, cleanedAnalysis);
    }
    updates.contextPerTest = cleanedContext;
  }

  return updates;
}

// ============================================================================
// Forward Declaration for Result Type (defined in reconciliation-result.ts)
// ============================================================================

// ReconciliationResult is defined in a separate file to avoid circular imports
// It will be imported where needed

// ============================================================================
// Graph State Definition
// ============================================================================

/**
 * Full state for the Reconciliation Agent graph.
 * Uses LangGraph's Annotation system for type-safe state management.
 */
export const ReconciliationGraphState = Annotation.Root({
  // -------------------------------------------------------------------------
  // Input Configuration
  // -------------------------------------------------------------------------

  /** Root directory of the repository */
  rootDirectory: Annotation<string>({
    reducer: (_, update) => update,
    default: () => '',
  }),

  /** Full input configuration */
  input: Annotation<ReconciliationInput | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Run ID for tracking and cancellation (passed from service layer) */
  runId: Annotation<string>({
    reducer: (_, update) => update,
    default: () => '',
  }),

  // -------------------------------------------------------------------------
  // Repository Structure (Phase: structure)
  // -------------------------------------------------------------------------

  /** Structure of the repository */
  repoStructure: Annotation<RepoStructure | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  // -------------------------------------------------------------------------
  // Orphan Tests (Phase: discover)
  // -------------------------------------------------------------------------

  /** Tests without @atom annotation (to be processed) */
  orphanTests: Annotation<OrphanTestInfo[]>({
    reducer: (_, update) => update,
    default: () => [],
  }),

  /**
   * Tests with @atom annotation that changed (delta mode only).
   * INV-R001: These MUST NOT flow to infer_atoms - only generate warnings.
   */
  changedAtomLinkedTests: Annotation<ChangedAtomLinkedTest[]>({
    reducer: (_, update) => update,
    default: () => [],
  }),

  /** Summary of delta changes (delta mode only) */
  deltaSummary: Annotation<DeltaSummary | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  // -------------------------------------------------------------------------
  // Context Enrichment (Phase: context)
  // -------------------------------------------------------------------------

  /** Documentation index for context enrichment */
  documentationIndex: Annotation<DocChunk[] | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Test analysis per test (key: filePath:testName) */
  contextPerTest: Annotation<Map<string, TestAnalysis>>({
    reducer: (_, update) => update,
    default: () => new Map(),
  }),

  // -------------------------------------------------------------------------
  // Inference Results (Phase: infer)
  // -------------------------------------------------------------------------

  /** Atoms inferred from tests */
  inferredAtoms: Annotation<InferredAtom[]>({
    reducer: (current, update) => [...current, ...update],
    default: () => [],
  }),

  // -------------------------------------------------------------------------
  // Molecule Synthesis (Phase: synthesize)
  // -------------------------------------------------------------------------

  /** Molecules synthesized from atoms */
  inferredMolecules: Annotation<InferredMolecule[]>({
    reducer: (_, update) => update,
    default: () => [],
  }),

  // -------------------------------------------------------------------------
  // Verification and Decisions (Phase: verify)
  // -------------------------------------------------------------------------

  /** Current phase of the reconciliation */
  currentPhase: Annotation<ReconciliationPhase>({
    reducer: (_, update) => update,
    default: () => 'structure' as ReconciliationPhase,
  }),

  /** Iteration count (for bounded loops) */
  iteration: Annotation<number>({
    reducer: (_, update) => update,
    default: () => 0,
  }),

  /** Maximum iterations allowed */
  maxIterations: Annotation<number>({
    reducer: (_, update) => update,
    default: () => 10,
  }),

  /** Accumulated errors during processing */
  errors: Annotation<string[]>({
    reducer: (current, update) => [...current, ...update],
    default: () => [],
  }),

  /** Decisions made during verification */
  decisions: Annotation<ReconciliationDecision[]>({
    reducer: (_, update) => update,
    default: () => [],
  }),

  /** Whether human review is pending (for interrupt support) */
  pendingHumanReview: Annotation<boolean>({
    reducer: (_, update) => update,
    default: () => false,
  }),

  /** Human review input after interrupt (populated on resume) */
  humanReviewInput: Annotation<HumanReviewInput | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Whether the run was resumed after an interrupt */
  wasResumed: Annotation<boolean>({
    reducer: (_, update) => update,
    default: () => false,
  }),

  // -------------------------------------------------------------------------
  // Output (Phase: persist)
  // -------------------------------------------------------------------------

  /** Final reconciliation result */
  output: Annotation<unknown | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  // -------------------------------------------------------------------------
  // Interim Persistence (Phase 6)
  // -------------------------------------------------------------------------

  /** Interim run ID (short form like REC-abc123) created before verification */
  interimRunId: Annotation<string | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Interim run UUID created before verification */
  interimRunUuid: Annotation<string | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  // -------------------------------------------------------------------------
  // Metadata
  // -------------------------------------------------------------------------

  /** Start time for duration tracking */
  startTime: Annotation<Date | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Count of LLM calls made */
  llmCallCount: Annotation<number>({
    reducer: (current, update) => current + update,
    default: () => 0,
  }),

  // -------------------------------------------------------------------------
  // Fixture Mode (Golden Test Evaluation)
  // -------------------------------------------------------------------------

  /** Whether running in fixture mode (golden tests) */
  fixtureMode: Annotation<boolean>({
    reducer: (_, update) => update,
    default: () => false,
  }),

  /** File contents for fixture mode (key: relative path, value: content) */
  fixtureFiles: Annotation<Record<string, string> | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Test file paths for fixture mode */
  fixtureTestFiles: Annotation<string[] | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Source file paths for fixture mode */
  fixtureSourceFiles: Annotation<string[] | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Existing annotations for fixture mode (key: "filePath:testName", value: atomId) */
  fixtureAnnotations: Annotation<Record<string, string> | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),

  /** Existing atoms for fixture mode */
  fixtureAtoms: Annotation<Array<{ id: string; description: string }> | null>({
    reducer: (_, update) => update,
    default: () => null,
  }),
});

export type ReconciliationGraphStateType = typeof ReconciliationGraphState.State;
